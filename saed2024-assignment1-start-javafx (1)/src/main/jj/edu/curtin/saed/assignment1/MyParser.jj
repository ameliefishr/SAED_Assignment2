PARSER_BEGIN(MyParser)

package edu.curtin.saed.assignment1;

import edu.curtin.saed.assignment1.MyParserTokenManager;
import edu.curtin.saed.assignment1.Token;
import edu.curtin.saed.assignment1.SimpleCharStream;
import edu.curtin.saed.assignment1.ParseException;

import java.util.*;
import java.io.*;

public class MyParser
{
    // class variables 
    public static int rows;
    public static int cols;
    public static int startRow;
    public static int startCol;
    public static int goalRow;
    public static int goalCol;
    public static String name;
    public static List<String> coordinates = new ArrayList<>();
    public static String message;
    public static Game game; // game instance

    // lists to store plugins, items, scripts and obstacles
    private static List<Item> items = new ArrayList<>();
    private static List<Obstacle> obstacles = new ArrayList<>();
    private static List<String> plugins = new ArrayList<>();
    private static List<String> scripts = new ArrayList<>();

    // function to parse the input file
    public static void parseFile(FileReader fileReader) throws ParseException, FileNotFoundException {

        MyParser parser = new MyParser(fileReader);
        
        MyParser.StartupDeclarations();  
        game.setGridWidth(rows);
        game.setGridHeight(cols);
        
        // printing for parser debugging <- REMOVE FOR FINAL SUBMISSION
        System.out.println("Parsed Game Variables:");
        System.out.println("Size: " + rows + " x " + cols);
        System.out.println("Start: (" + startRow + "," + startCol + ")");
        System.out.println("Goal: (" + goalRow + "," + goalCol + ")");
        System.out.println("Parsed Item: " + name);
        System.out.println("Coordinates: " + coordinates);
        System.out.println("Message: " + message);
        System.out.println("Items: " + items);
        System.out.println("Obstacles: " + obstacles);
        System.out.println("Plugins: " + plugins);
        System.out.println("Scripts: " + scripts);
    }

    private static void initializeGame() {
        Location playerLocation = new Location(startRow, startCol);
        Location goalLocation = new Location(goalRow, goalCol);

        // majority of the variables in game are empty to start, will be populated later on
        game = new Game(playerLocation, goalLocation, new ArrayList<>(), new ArrayList<>());

        // print for debugging <- REMOVE FOR SUBMISSIOn
        System.out.println("Game Initialized:");
        System.out.println("Player Start Location: " + playerLocation.toString());
        System.out.println("Goal Location: " + goalLocation.toString());
    }

    // parses coordinate string into an int array of x and y coords so can be made into location object
    private static int[] parseCoordinates(String coordStr) {
        String[] parts = coordStr.split(","); 
        int x = Integer.parseInt(parts[0].trim());
        int y = Integer.parseInt(parts[1].trim()); 
        return new int[]{x, y}; 
    }

// only call AFTER ininitalizeGame or game will be null
    public static Game getGameInstance() {
        return game; 
    }    
}

PARSER_END(MyParser)

// things to skip when parsing
SKIP : {
    " " | "\t" | "\r" | "\n" // Skip spaces, tabs, and newlines
}

// token definitions
TOKEN : {
    <SIZE: "size"> |
    <START: "start"> |
    <GOAL: "goal"> |
    <ITEM: "item"> |
    <AT: "at"> |
    <MESSAGE: "message"> |
    <OBSTACLE: "obstacle"> |
    <REQUIRES: "requires"> |
    <PLUGIN: "plugin"> |
    <SCRIPT: "script"> | 
    <CLASS: "class"> |
    <DEF: "def"> |
    <HANDLEEVENT: "handleEvent"> |
    <PRINT: "print"> |
    <IDENTIFIER: (["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9", "_"])* )> | 
    <DOT: "."> | 
    <LPAREN: "("> |
    <RPAREN: ")"> |
    <LBRACE: "{"> |
    <RBRACE: "}"> |
    <COMMA: ","> |
    <STRING_LITERAL: "\"" (~["\""])* "\"" > |
    <NUMBER: (["0"-"9"])+> |
    <COLON: ":"> |
    <EXCLAMATION: "!"> 
}

// statup declarations, defines the structure & order of which to parse the input file
void StartupDeclarations() : 
{
} 
{
    // always read these first, and only once
    SizeDeclaration() 
    StartDeclaration() 
    GoalDeclaration()

    // initialize game object with the initial variables (size, start, goal)
    {
        initializeGame();
    }

    // check for any number or combination of plugin, script, item or obstacle declaration
    ( LOOKAHEAD(1) 
        ( 
            ItemDeclaration() 
        | 
            ObstacleDeclaration() 
        | 
            PluginDeclarations() 
        | 
            ScriptDeclarations() 
        )
    )*
}


// game size declaration
void SizeDeclaration() : 
{
    Token rowToken;
    Token colToken;
} 
{
    <SIZE> <LPAREN> rowToken = <NUMBER> <COMMA> colToken = <NUMBER> <RPAREN>
    {
        rows = Integer.parseInt(rowToken.image);
        cols = Integer.parseInt(colToken.image);
        
        if (rows < 1 || cols < 1) {
            throw new ParseException("Invalid size values. Must be at least 1.");
        }
    }
}

// start location declaration
void StartDeclaration() : 
{
    Token startRowToken;
    Token startColToken;
} 
{
    <START> <LPAREN> startRowToken = <NUMBER> <COMMA> startColToken = <NUMBER> <RPAREN>
    {
        startRow = Integer.parseInt(startRowToken.image);
        startCol = Integer.parseInt(startColToken.image);
        if (startRow < 0 || startRow >= rows || startCol < 0 || startCol >= cols) {
            throw new ParseException("Invalid start location. Must be within grid bounds.");
        }
    }
}

// goal location declaration
void GoalDeclaration() : 
{
    Token goalRowToken;
    Token goalColToken;
} 
{
    <GOAL> <LPAREN> goalRowToken = <NUMBER> <COMMA> goalColToken = <NUMBER> <RPAREN>
    {
        goalRow = Integer.parseInt(goalRowToken.image);
        goalCol = Integer.parseInt(goalColToken.image);
        if (goalRow < 0 || goalRow >= rows || goalCol < 0 || goalCol >= cols) {
            throw new ParseException("Invalid goal location. Must be within grid bounds.");
        }
    }
}

// item declaration
void ItemDeclaration() : 
{
    Token nameToken; 
    List<Location> locList = new ArrayList<>();
} 
{
    <ITEM> nameToken = <STRING_LITERAL> <LBRACE> AtDeclaration(locList) MessageDeclaration() <RBRACE>
    {
        name = nameToken.image.substring(1, nameToken.image.length() - 1); 
        
        List<Location> itemLocations = new ArrayList<>(locList);
        
        Item item = new Item(name, itemLocations, message);
        items.add(item);
        game.addItem(item);  
    }
}

// obstacle declaration
void ObstacleDeclaration() : 
{
    List<Location> locList = new ArrayList<>();
    List<Item> requiredItems = new ArrayList<>();
} 
{
    <OBSTACLE> <LBRACE> AtDeclaration(locList) RequiresDeclaration(requiredItems) <RBRACE>
    {
        Location obstacleLocation = locList.get(0);
        List<Location> obstacleLocations = new ArrayList<>();
        obstacleLocations.add(obstacleLocation);
        Obstacle obstacle = new Obstacle(obstacleLocations, requiredItems);
        obstacles.add(obstacle);
        game.addObstacle(obstacle);
    }
}

// plugin declaration
void PluginDeclarations() : 
{
    Token pluginName;
} 
{
    <PLUGIN> QualifiedName() 
    {
        //System.out.println("Parsed Plugin:");
        //System.out.println(plugins);
    }
}

// used in plugin declaration
void QualifiedName() : 
{
    Token part;
    StringBuilder qualifiedName = new StringBuilder();
} 
{
    part = <IDENTIFIER> 
    {
        qualifiedName.append(part.image);
    }
    ( <DOT> part = <IDENTIFIER> 
    {
        qualifiedName.append("." + part.image);
    })*
    {
        plugins.add("Plugin: " + qualifiedName.toString());
    }
}

// script declaration
void ScriptDeclarations() : 
{
    Token scriptName;
} 
{
    <SCRIPT> <EXCLAMATION> <LBRACE> ScriptBlock() <RBRACE> 
    {
        //System.out.println("Parsed Script:");
        //System.out.println(scripts);
    }
}

// script block declaration - used in script declaration
void ScriptBlock() : 
{
} 
{
    <CLASS> ClassDeclaration() 
}

// class declaration - used in script declaration
void ClassDeclaration() : 
{
    Token className, superClass;
} 
{
    className = <IDENTIFIER> <LPAREN> QualifiedNameScript() <RPAREN> <COLON> MethodDeclaration() 
    {
        scripts.add("Class: " + className.image);
    }
}

// qualified name for script declaration (differs to the one for plugin)
void QualifiedNameScript() : 
{
    Token part;
} 
{
    part = <IDENTIFIER> ( <DOT> part = <IDENTIFIER> )* 
    {
        scripts.add("Superclass: " + part.image);  
    }
}

// method declaration - used by script declaration
void MethodDeclaration() : 
{
    Token methodName;
} 
{
    methodName = <DEF> <HANDLEEVENT> <LPAREN> <IDENTIFIER> <RPAREN> <COLON> StatementBlock() 
    {
        scripts.add("Method: " + methodName.image);
    }
}

// single coordinate pair
void Coordinate(List<Location> locList) : 
{
    Token x; 
    Token y;
} 
{
    <LPAREN> x = <NUMBER> <COMMA> y = <NUMBER> <RPAREN>
    {
        locList.add(new Location(Integer.parseInt(x.image), Integer.parseInt(y.image)));
    }
}

// at declaration (proceeds list of locations)
void AtDeclaration(List<Location> locList) : 
{
} 
{
    <AT> CoordinateList(locList)
}

// list of coordinate pairs 
void CoordinateList(List<Location> locList) : 
{
} 
{
    Coordinate(locList) ( <COMMA> Coordinate(locList) )*
}

// message declaration
void MessageDeclaration() : 
{
    Token msgToken;
} 
{
    <MESSAGE> msgToken = <STRING_LITERAL>
    {
        message = msgToken.image.substring(1, msgToken.image.length() - 1); 
    }
}

// statement block declaration
void StatementBlock() : 
{
} 
{
    <PRINT> <LPAREN> <IDENTIFIER> <DOT> <IDENTIFIER> <LPAREN> <RPAREN> <RPAREN> 
    {
        scripts.add("Statement: print(api.getSomeInfo())");
    }
}

// requires declaration (for required items) - used by obstacle declaration
void RequiresDeclaration(List<Item> requiredItems) : 
{ 
    Token itemToken; 
    List<String> tempItems = new ArrayList<>();
} 
{ 
    <REQUIRES> itemToken = <STRING_LITERAL> ( <COMMA> itemToken = <STRING_LITERAL> )* 
    {
        tempItems.add(itemToken.image);
        
        for (String item : tempItems) {
            String itemName = item.substring(1, item.length() - 1); // 1, -1 to remove the "" quotes
            requiredItems.add(new Item(itemName, new ArrayList<Location>(), "Some String")); 
        }
    }
}
